{-# OPTIONS_GHC -Wno-incomplete-uni-patterns #-}

{-# LANGUAGE NoOverloadedStrings #-}
{-# LANGUAGE DeriveLift #-}
{-# LANGUAGE TemplateHaskellQuotes #-}
{-# LANGUAGE UnboxedTuples #-}

module XML (
    -- * Types
    XMLNode(..),
    XPathExpr(..),
    XPathComponent(..),
    Predicate(..),
    -- * Functions
    evaluateXPathExpr,
    evalXPathAsText,
    parseXPath,
    nodeText,
    nodeName,
    nodeAttribute,
    makeNode,
    makeNodes,
    parentOf,
    joinXPathExpr,
    -- * XML Creation
    makeTextNode,
    makeAttributedNode,
    makeElementNode,
    addAttributes,
    -- * Quasi-quoter
    x
) where

import Data.Text (Text)
import qualified Data.Map as Map -- Added for merging attributes
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as BSC
import qualified Text.XML.Hexml as X
import Text.Parsec -- Removed hiding (try)
import Text.Parsec.String (Parser)
-- Removed redundant import: import Control.Applicative (liftA2)
import Language.Haskell.TH.Quote
import Language.Haskell.TH.Syntax (Lift)
import Data.List (intercalate, foldl', dropWhileEnd)
import Data.Char (isSpace)
import Data.Set (Set)
import qualified Data.Set as Set

-- | Our XMLNode type that includes index information
data XMLNode = XMLNode
    { xmlNode :: X.Node         -- ^ The underlying XML node
    , xmlNodeIndex :: Int       -- ^ Index among siblings with same name
    , xmlNodeParent :: Maybe XMLNode  -- ^ Parent node if any
    } | XMLText
    { xmlText :: BS.ByteString  -- ^ Raw text content
    , xmlNodeIndex :: Int       -- ^ Index for the text node. For sequences generated by functions like 'tokenize', this is the 1-based index within that sequence. Otherwise, typically 0.
    , xmlNodeParent :: Maybe XMLNode  -- ^ Parent node if any
    }

instance Eq XMLNode where
    (XMLNode n1 _ _) == (XMLNode n2 _ _) = X.outer n1 == X.outer n2
    (XMLText t1 _ _) == (XMLText t2 _ _) = t1 == t2
    _ == _ = False

instance Ord XMLNode where
    compare (XMLNode n1 _ _) (XMLNode n2 _ _) = compare (X.outer n1) (X.outer n2)
    compare (XMLText t1 _ _) (XMLText t2 _ _) = compare t1 t2
    compare XMLNode{} XMLText{} = LT
    compare XMLText{} XMLNode{} = GT

-- | XPath component types
-- | Parsed XPath expression
newtype XPathExpr = XPathExpr { unXPathExpr :: [XPathComponent] }
    deriving (Eq, Lift)

instance Show XPathExpr where
    show (XPathExpr components) = intercalate "/" (map show components)

data XPathComponent
    = Current                    -- ^ Current node (.)
    | Parent                     -- ^ Parent node (..)
    | TextNode                   -- ^ text() function
    | Attribute BS.ByteString          -- ^ @attribute
    | Element BS.ByteString [Predicate] -- ^ element[pred1][pred2]...
    | Preceding BS.ByteString
    | Concat [XPathExpr]         -- ^ concat(expr1 + expr2 + ...) - Takes XPathExpr now
    | SubstringAfter XPathComponent BS.ByteString  -- ^ substring-after(expr, str)
    | Substring XPathComponent Int Int  -- ^ substring(expr, start, len)
    | StringJoin XPathExpr BS.ByteString  -- ^ string-join(sequence, separator) - Takes XPathExpr now
    | NormalizeSpace XPathExpr       -- ^ normalize-space(expr) - Takes XPathExpr now
    | MarcValue                  -- ^ marc-value()
    | Tokenize XPathExpr [BS.ByteString] -- ^ tokenize(expr, separator(s))
    | LiteralString BS.ByteString    -- ^ "string literal" or 'string literal'
    | Count XPathExpr
    | Function BS.ByteString [XPathComponent] -- ^ Generic function call (used internally by parser)
    deriving (Eq, Lift)

-- Helper to show ByteString as a quoted string, preferring single quotes
-- and escaping internal single quotes if necessary.
showQuotedBS :: BS.ByteString -> String
showQuotedBS bs =
    let s = T.unpack (TE.decodeUtf8 bs)
    in if '\'' `elem` s
       then "\"" ++ concatMap (\c -> if c == '"' then "\\\"" else [c]) s ++ "\""
       else "'" ++ s ++ "'"

instance Show XPathComponent where
    show Current = "."
    show Parent = ".."
    show TextNode = "text()"
    show (Attribute attr) = "@" ++ BSC.unpack attr -- Attribute names are typically ASCII
    show (Element name preds) = BSC.unpack name ++ concatMap show preds -- Element names are typically ASCII
    show (Preceding name) = "preceding::" ++ BSC.unpack name
    show (Concat exprs) = "concat(" ++ intercalate ", " (map show exprs) ++ ")"
    show (SubstringAfter expr str) = "substring-after(" ++ show expr ++ ", " ++ showQuotedBS str ++ ")"
    show (Substring expr start len) = "substring(" ++ show expr ++ ", " ++ show start ++ ", " ++ show len ++ ")"
    show (StringJoin expr sep) = "string-join(" ++ show expr ++ ", " ++ showQuotedBS sep ++ ")"
    show (NormalizeSpace expr) = "normalize-space(" ++ show expr ++ ")"
    show MarcValue = "marc-value()"
    show (Tokenize expr seps) = "tokenize(" ++ show expr ++ ", " ++ showCombinedSeps seps ++ ")"
      where
        showCombinedSeps :: [BS.ByteString] -> String
        showCombinedSeps [sep] = showQuotedBS sep -- If only one, show it as a simple string literal
        showCombinedSeps ss = showQuotedBS $ TE.encodeUtf8 $ T.intercalate (T.pack "|") $
                                map (\s -> T.concat [T.pack "(", TE.decodeUtf8 s, T.pack ")"]) ss
    show (LiteralString bs) = showQuotedBS bs
    show (Count expr) = "count(" ++ show expr ++ ")"
    show (Function name args) = BSC.unpack name ++ "(" ++ intercalate ", " (map show args) ++ ")" -- Function names are typically ASCII

data Predicate
    = AttrPredicate BS.ByteString BS.ByteString -- ^ @attr='value'
    | AndPredicate [Predicate]    -- ^ pred1 and pred2 and ...
    deriving (Eq, Lift)

instance Show Predicate where
    show (AttrPredicate attr val) = "[" ++ "@" ++ BSC.unpack attr ++ "='" ++ T.unpack (TE.decodeUtf8 val) ++ "']" -- attr is ASCII, val can be UTF-8
    show (AndPredicate preds) = "[" ++ intercalate " and " (map (init . tail . show) preds) ++ "]"

-- Set of known and supported XPath function names
knownFunctions :: Set BS.ByteString
knownFunctions = Set.fromList
    [ BSC.pack "concat"
    , BSC.pack "substring-after"
    , BSC.pack "substring"
    , BSC.pack "string-join"
    , BSC.pack "normalize-space"
    , BSC.pack "marc-value"
    , BSC.pack "tokenize"
    , BSC.pack "count"
    -- Note: text() is handled separately as TextNode
    ]

-- | Parses the arguments for the concat function.
-- Expects: arg1, arg2, ... where each arg is an XPath expression or a string literal.
parseConcatArgs :: Parser [XPathExpr]
parseConcatArgs = sepBy1 (xpathArgParser <|> literalStringParser) (spaces >> char ',' >> spaces)
  where
    -- Each argument to concat is parsed as a full XPath expression (without expecting eof)
    xpathArgParser = xpathExprParser'
    -- Parser for a string literal, wrapped as an XPathExpr with a LiteralString component
    literalStringParser = do
        s <- quotedStringBS
        return $ XPathExpr [LiteralString s]

-- | Parses the arguments for substring-after.
-- Expects: expr, 'string'
parseSubstringAfterArgs :: Parser (XPathComponent, BS.ByteString)
parseSubstringAfterArgs = do
    expr <- componentParser
    spaces >> char ',' >> spaces
    str <- quotedStringBS
    return (expr, str)

-- | Parses the arguments for string-join.
-- Expects: pathExpr, 'separator'
parseStringJoinArgs :: Parser (XPathExpr, BS.ByteString)
parseStringJoinArgs = do
    -- Allow a full XPath expression as the first argument
    expr <- xpathExprParser' -- Use a modified parser that doesn't expect eof
    spaces >> char ',' >> spaces
    sep <- quotedStringBS
    return (expr, sep)

-- | Parses the arguments for normalize-space.
-- Expects: expr (a full XPath expression)
parseNormalizeSpaceArgs :: Parser XPathExpr
parseNormalizeSpaceArgs = xpathExprParser' -- Parse the full expression within the parens

-- | Parses the arguments for count.
-- Expects: expr (a full XPath expression)
parseCountArgs :: Parser XPathExpr
parseCountArgs = xpathExprParser'

-- | Parses the arguments for tokenize.
-- Expects: pathExpr, 'separator_literal'
-- The separator_literal can be a simple string like ',' or a complex one like '(s1)|(s2)'
parseTokenizeArgs :: Parser (XPathExpr, [BS.ByteString])
parseTokenizeArgs = do
    expr <- xpathExprParser'
    spaces >> char ',' >> spaces
    rawSepBS <- quotedStringBS
    let rawSepString = T.unpack (TE.decodeUtf8 rawSepBS) -- Convert to String for Parsec

    -- Try to parse rawSepString using multiSeparatorParser
    -- It must parse the *entire* rawSepString.
    case parse (multiSeparatorParser <* eof) "" rawSepString of
        Right parsedSeps ->
            -- Ensure parsedSeps is not empty, which sepBy1 should guarantee.
            -- If it were possible for multiSeparatorParser to return [], fallback.
            if null parsedSeps
            then return (expr, [rawSepBS]) -- Fallback, treat as single literal
            else return (expr, parsedSeps)
        Left _           -> return (expr, [rawSepBS]) -- Fallback: treat as single literal separator

-- | Helper parser for the (s1)|(s2)|... format. Input is the content of the string literal.
-- Example: For tokenize(expr, '(,)|(.)'), this parser gets "(,)|(.)" as input string.
multiSeparatorParser :: Parser [BS.ByteString]
multiSeparatorParser = sepBy1 singleSep (spaces >> char '|' >> spaces)
  where
    -- A single separator like (.) or ( & )
    -- Content within () must be non-empty.
    singleSep :: Parser BS.ByteString
    singleSep = between (char '(') (char ')') (TE.encodeUtf8 . T.pack <$> many1 (noneOf ")"))

-- | Parses the arguments for substring.
-- Expects: expr, number, number
parseSubstringArgs :: Parser (XPathComponent, Int, Int)
parseSubstringArgs = do
    expr <- componentParser
    spaces >> char ',' >> spaces
    start <- read <$> many1 digit
    spaces >> char ',' >> spaces
    len <- read <$> many1 digit
    return (expr, start, len)

-- | Parses a string literal enclosed in single or double quotes.
quotedString :: Parser String
quotedString = between (char '\'') (char '\'') (many (noneOf "'"))
    <|> between (char '"') (char '"') (many (noneOf "\""))

-- | Parses a quoted string and returns it as a ByteString (UTF-8 encoded).
quotedStringBS :: Parser BS.ByteString
quotedStringBS = (TE.encodeUtf8 . T.pack) <$> quotedString

-- | Parses a generic function call like `funcName(arg1, arg2, ...)`
-- Validates funcName against `knownFunctions`.
functionCallParser :: Parser XPathComponent
functionCallParser = do
    funcNameBS <- BSC.pack <$> many1 (letter <|> char '-') -- Parse the function name identifier
    _ <- char '('
    spaces
    -- Check if the function name is known/supported
    if Set.member funcNameBS knownFunctions then do
        -- Dispatch to the specific argument parser based on the function name
        component <- case BSC.unpack funcNameBS of
            "concat"          -> Concat <$> parseConcatArgs
            "substring-after" -> uncurry SubstringAfter <$> parseSubstringAfterArgs
            "substring"       -> (\(e, s, l) -> Substring e s l) <$> parseSubstringArgs
            "string-join"     -> uncurry StringJoin <$> parseStringJoinArgs
            "normalize-space" -> NormalizeSpace <$> parseNormalizeSpaceArgs -- Now expects XPathExpr
            "marc-value"      -> return MarcValue -- No arguments for marc-value
            "tokenize"        -> uncurry Tokenize <$> parseTokenizeArgs
            "count"           -> Count <$> parseCountArgs
            _                 -> unexpected $ "Internal error: Unhandled known function: " ++ BSC.unpack funcNameBS
        spaces
        _ <- char ')'
        -- For marc-value, ensure no arguments were passed if we decide to make it strict
        -- For now, the parser structure handles it by not expecting arguments for MarcValue path.
        return component
    else
        -- Fail parsing if the function name is not recognized
        fail $ "Unknown or unsupported XPath function: " ++ BSC.unpack funcNameBS

-- | Parses a single step in an XPath expression.
componentParser :: Parser XPathComponent
componentParser = choice $ map try -- Use try for backtracking between choices
    [ string ".." >> return Parent
    , string "." >> return Current
    , string "text()" >> return TextNode
    , attributeParser
    , precedingAxisParser
    , functionCallParser -- Try parsing a function call
    , elementParser      -- Must be after functionCallParser as element names can resemble function names
    ]

-- | Parser for attribute references (@attr)
attributeParser :: Parser XPathComponent
attributeParser = do
    _ <- char '@'
    -- Allow namespaces in attribute names
    attrName <- liftA2 (:) (letter <|> char '_') (many (letter <|> digit <|> char '_' <|> char '-' <|> char ':'))
    return $ Attribute (BSC.pack attrName)

precedingAxisParser :: Parser XPathComponent
precedingAxisParser = do
    _ <- string "preceding::"
    -- Support for wildcard '*' or a specific element name
    elementName <- (string "*" >> return "*") <|> liftA2 (:) (letter <|> char '_') (many (letter <|> digit <|> char '_' <|> char '-' <|> char ':'))
    return $ Preceding (BSC.pack elementName)

-- | Parser for element names with optional predicates
elementParser :: Parser XPathComponent
elementParser = do
    -- Allow namespaces in element names
    elementName <- liftA2 (:) (letter <|> char '_') (many (letter <|> digit <|> char '_' <|> char '-' <|> char ':'))
    spaces  -- Allow whitespace before predicates
    predicates <- many (predicateParser <* spaces) -- Removed unnecessary try
    return $ Element (BSC.pack elementName) predicates

-- | Parser for predicates
predicateParser :: Parser Predicate
predicateParser = between (char '[') (char ']') $ do
    preds <- sepBy1 singlePredicateParser (try andOperator)
    return $ case preds of
        [single] -> single
        multiple -> AndPredicate multiple
  where
    andOperator = try $ spaces >> string "and" >> spaces

-- | Parser for a single predicate
singlePredicateParser :: Parser Predicate
singlePredicateParser = attrPredicateParser

-- | Parser for attribute predicates (@attr='value')
attrPredicateParser :: Parser Predicate
attrPredicateParser = do
    _ <- char '@'
    -- Allow namespaces in attribute predicate names
    attrPredName <- liftA2 (:) (letter <|> char '_') (many (letter <|> digit <|> char '_' <|> char '-' <|> char ':'))
    spaces
    _ <- char '='
    spaces
    AttrPredicate (BSC.pack attrPredName) <$> quotedStringBS

-- | Parses a full XPath expression (sequence of components separated by '/')
xpathExprParser' :: Parser XPathExpr -- Renamed: Doesn't expect eof, for use within functions
xpathExprParser' = do
    spaces
    _ <- optional (char '/') -- Handle optional leading slash
    components <- sepBy1 componentParser (spaces >> char '/' >> spaces)
    spaces
    -- Filter out '.' steps as they are redundant unless it's the only component
    return $ XPathExpr $ case components of
        [Current] -> [Current] -- Keep single '.'
        _         -> filter (/= Current) components

-- | Parses a full XPath expression (sequence of components separated by '/')
-- This version expects to consume the entire input (eof).
xpathExprParser :: Parser XPathExpr
xpathExprParser = xpathExprParser' <* eof

-- | Parse an XPath string, returning Left ParseError on failure.
parseXPath :: String -> Either ParseError XPathExpr
parseXPath = parse xpathExprParser "" -- Use the eof-expecting parser for the main entry point

-- | Evaluate the parsed XPath expression starting from a given node.
evaluateXPathExpr :: XMLNode -> XPathExpr -> [XMLNode]
evaluateXPathExpr node (XPathExpr components) = foldl' evaluateComponent [node] components
  where
    evaluateComponent :: [XMLNode] -> XPathComponent -> [XMLNode]
    evaluateComponent nodes component =
        let go [] acc = acc
            go (n:ns) acc = go ns (acc ++ evaluateStep component n)
        in go nodes []

-- | Evaluate XPath and return text content of a single resulting node.
-- Returns Nothing if no node is found.
-- Fails with an error if multiple nodes are found.
evalXPathAsText :: XMLNode -> XPathExpr -> Maybe Text
evalXPathAsText node expr =
    case evaluateXPathExpr node expr of
        []    -> Nothing
        [n]   -> Just (nodeText n)
        (_:_:_) -> error $ "evalXPathAsText: XPath expression \"" ++ show expr ++ "\" returned multiple nodes."

attributeLookup :: X.Node -> BS.ByteString -> Maybe BS.ByteString
attributeLookup n attr = X.attributeValue <$> X.attributeBy n attr

evaluateStep :: XPathComponent -> XMLNode -> [XMLNode]
evaluateStep Current currentNode = [currentNode]
evaluateStep Parent currentNode =
    case xmlNodeParent currentNode of
        Just parent -> [parent]
        Nothing -> []
evaluateStep TextNode currentNode@(XMLNode xnode _ _) =
    case X.contents xnode of
        [] -> []  -- No text content
        contents ->
            let textContent = BS.concat [txt | Left txt <- contents, not (BS.null txt)]
            in [XMLText textContent 0 (Just currentNode)]  -- Always return a node for chaining
evaluateStep TextNode currentNode@(XMLText txt _ _) =
    [XMLText txt 0 (Just currentNode)]  -- Return text node as-is
evaluateStep (Attribute attr) currentNode@(XMLNode xnode _ _) =
    case attributeLookup xnode attr of
        Just value -> [XMLText value 0 (Just currentNode)]
        Nothing -> []
evaluateStep (Element name preds) currentNode@(XMLNode xnode _ _) =
    let children = X.childrenBy xnode name -- Get X.Node list, already filtered by name
        -- Predicates (now only AttrPredicate) match on X.Node
        filteredChildren = filter (matchPredicates preds) children
        parentNode = Just currentNode
    -- makeNodes will assign xmlNodeIndex based on the filteredChildren list
    in makeNodes filteredChildren parentNode
evaluateStep (Preceding name) node =
    let
        -- 1. Find the root of the document
        getRoot :: XMLNode -> XMLNode
        getRoot n = case xmlNodeParent n of
            Just p  -> getRoot p
            Nothing -> n

        -- 2. Perform a depth-first traversal from the root to collect all nodes
        --    in document order.
        collectAllNodes :: XMLNode -> [XMLNode]
        collectAllNodes n =
            let children = case n of
                    XMLNode xn _ _ -> makeNodes (X.children xn) (Just n)
                    XMLText {}     -> []
            in n : concatMap collectAllNodes children

        allNodesInOrder = collectAllNodes (getRoot node)
        
        -- Find all nodes that precede the context node in document order.
        allPreceding = takeWhile (/= node) allNodesInOrder

        -- 4. Filter by name, if not a wildcard.
        -- Note: This implementation deviates from the W3C XPath 1.0 spec for the
        -- `preceding` axis, which states that ancestors are not included.
        -- This version *does* include ancestors. The tests confirm this behavior.
        filteredNodes = if name == BSC.pack "*"
            -- When using wildcard, filter out the ephemeral root node which has no name.
            then filter (\n -> case n of
                                  (XMLNode xn _ _) -> not (BS.null (X.name xn))
                                  _                -> False
                        ) allPreceding
            else filter (\n -> case n of
                                (XMLNode xn _ _) -> X.name xn == name
                                _                -> False
                        ) allPreceding

    -- 5. The `preceding` axis is in reverse document order.
    in reverse filteredNodes
evaluateStep (Concat exprs) node =
    let
        evaluateArgToText :: XPathExpr -> Text
        -- If the argument is a simple literal string, decode it directly without stripping.
        evaluateArgToText (XPathExpr [LiteralString bs]) = decodeUtf8Safe bs
        -- For other XPath expressions, evaluate them and then get the nodeText (which includes stripping).
        evaluateArgToText expr =
            case evaluateXPathExpr node expr of
                []    -> T.empty -- XPath string() conversion: empty node-set to empty string
                (n:_) -> nodeText n -- XPath string() conversion: first node's string value (strips whitespace)
        
        texts = map evaluateArgToText exprs
        joined = T.concat texts
    in [XMLText (TE.encodeUtf8 joined) 0 (Just node)]
evaluateStep (LiteralString s) node =
    [XMLText s 0 (Just node)] -- Treat literal string as a text node
evaluateStep (SubstringAfter expr str) node =
    case evaluateStep expr node of
        [] -> [XMLText (BSC.pack "") 0 (Just node)]  -- Return empty node for chaining
        (n:_) ->
            let text = nodeText n
                searchStr = TE.decodeUtf8 str
                afterStr = T.unpack $ case T.breakOn searchStr text of
                    (_, rest) | T.null rest -> T.empty  -- String not found
                             | otherwise -> T.drop (T.length searchStr) rest
            in [XMLText (TE.encodeUtf8 (T.pack afterStr)) 0 (Just node)]
evaluateStep (Substring expr start len) node =
    case evaluateStep expr node of
        [] -> [XMLText (BSC.pack "") 0 (Just node)]  -- Return empty node for chaining
        (n:_) ->
            let text = nodeText n
                textLen = T.length text
                safeStart = max 0 (start - 1)  -- XPath is 1-based
                safeLen = if safeStart >= textLen
                          then 0
                          else min len (textLen - safeStart)
                substr = T.take safeLen $ T.drop safeStart text
            in [XMLText (TE.encodeUtf8 substr) 0 (Just node)]
evaluateStep (NormalizeSpace expr) node = -- Handles XPathExpr argument
    -- First, evaluate the argument expression
    case evaluateXPathExpr node expr of
        [] -> [XMLText (BSC.pack "") 0 (Just node)]  -- Return empty node if argument yields nothing
        (n:_) -> -- Take the first node from the result of the argument expression
            let text = nodeText n -- Get text from that node
                -- Use words/unwords directly - more efficient for whitespace normalization
                normalized = if T.null text then T.empty else T.unwords $ T.words text
            in [XMLText (TE.encodeUtf8 normalized) 0 (Just node)]
evaluateStep MarcValue node =
    -- marc-value() operates on the text() of the current node.
    -- So, first get the text content.
    case evaluateStep TextNode node of
        [] -> [XMLText BS.empty 0 (Just node)] -- No text content, return empty
        (XMLText textContent _ _ : _) -> -- TextNode always returns a list with one XMLText or empty
            let text = decodeUtf8Safe textContent
                -- Trim leading/trailing dots, commas, and whitespace
                finalText = T.dropAround (\c -> c == '.' || c == ',' || isSpace c) text
            in [XMLText (TE.encodeUtf8 finalText) 0 (Just node)]
        _ -> [XMLText BS.empty 0 (Just node)] -- Should not happen if TextNode behaves as expected
evaluateStep (StringJoin exprComponents sep) node = -- Now takes XPathExpr directly
    let nodes = evaluateXPathExpr node exprComponents
    in case nodes of
        [] -> [XMLText (BSC.pack "") 0 (Just node)]  -- Return empty node for chaining
        xs ->
            let texts = map nodeText xs
                joined = T.intercalate (decodeUtf8Safe sep) texts
            in [XMLText (TE.encodeUtf8 joined) 0 (Just node)]
evaluateStep (Tokenize expr separatorsBS) node =
    case evaluateXPathExpr node expr of
        [] -> [] -- If the expression yields no node, tokenize results in no nodes
        (n:_) -> -- Take the first node from the result of the argument expression
            let
                textToTokenize = nodeText n -- This already strips the overall text
                separatorsText = map decodeUtf8Safe separatorsBS -- Convert all BS separators to Text

                -- Start with a list containing the initial string.
                -- For each separator, apply splitOn to every string in the current list of parts and flatten.
                initialParts = [textToTokenize]

                -- The parser ensures separatorsText is non-empty.
                finalParts = foldl' (\currentParts sepTxt ->
                                 concatMap (\part -> T.splitOn sepTxt part) currentParts
                             ) initialParts separatorsText

                trimmedParts = map T.strip finalParts -- Strip each part individually
                nonEmptyParts = filter (not . T.null) trimmedParts
            -- Assign 0-based indices to the tokenized parts
            in zipWith (\txt idx -> XMLText (TE.encodeUtf8 txt) idx (Just node)) nonEmptyParts [0..]
evaluateStep (Count expr) node =
    let
        nodes = evaluateXPathExpr node expr
        count = length nodes
    in [XMLText (TE.encodeUtf8 $ T.pack $ show count) 0 (Just node)]
-- Handle the Function constructor - this should not be reached in normal evaluation
-- as the parser resolves Function into specific constructors like Concat, StringJoin etc.
evaluateStep (Function name _) _ =
    error $ "evaluateStep: Encountered unresolved Function constructor during evaluation: " ++ BSC.unpack name
evaluateStep _ (XMLText {}) = []  -- Text nodes have no children or attributes

matchPredicates :: [Predicate] -> X.Node -> Bool
matchPredicates preds n = all (`matchPredicate` n) preds

matchPredicate :: Predicate -> X.Node -> Bool
matchPredicate (AttrPredicate attr value) n =
    case attributeLookup n attr of
        Just v -> v == value
        Nothing -> False
matchPredicate (AndPredicate preds) n = all (`matchPredicate` n) preds

-- | Safely decode UTF-8 text with fallback to char8 decoding
decodeUtf8Safe :: BS.ByteString -> Text
decodeUtf8Safe = TE.decodeUtf8

-- | Extract direct text content from a node (non-recursive), decoding XML entities
-- and trimming leading/trailing whitespace.
nodeText :: XMLNode -> Text
nodeText (XMLNode node _ _) =
    case X.contents node of
        [] -> T.empty
        contents ->
            let texts = [decodeXMLEntities (decodeUtf8Safe txt) | Left txt <- contents, not (BS.null txt)]
            -- Concatenate all direct text children, then strip whitespace from the combined string.
            in T.strip $ T.concat texts
nodeText (XMLText txt _ _) = T.strip $ decodeXMLEntities (decodeUtf8Safe txt) -- Strip whitespace from the text content

nodeName :: XMLNode -> Text
nodeName (XMLNode node _ _) = decodeUtf8Safe $ X.name node
nodeName (XMLText {}) = T.empty

nodeAttribute :: XMLNode -> BS.ByteString -> Maybe Text
nodeAttribute (XMLNode node _ _) attribute = (decodeXMLEntities . TE.decodeUtf8) <$> attributeLookup node attribute
nodeAttribute _ _ = error "Attributes can be access only on element nodes"

-- | Decode common XML entities
decodeXMLEntities :: Text -> Text
decodeXMLEntities = T.replace (T.pack "&amp;") (T.pack "&")
                    . T.replace (T.pack "&lt;") (T.pack "<")
                    . T.replace (T.pack "&gt;") (T.pack ">")
                    . T.replace (T.pack "&quot;") (T.pack "\"")
                    . T.replace (T.pack "&apos;") (T.pack "'")
                    . T.replace (T.pack "&nbsp;") (T.pack " ")
                    . T.replace (T.pack "&#039;") (T.pack "'")
                    . T.replace (T.pack "&#034;") (T.pack "\"")

-- | Create a XMLNode with index information
makeNode :: X.Node -> [X.Node] -> Int -> Maybe XMLNode -> XMLNode
makeNode n _ = XMLNode n

-- | Create nodes with indices from a list of XML nodes
makeNodes :: [X.Node] -> Maybe XMLNode -> [XMLNode]
makeNodes nodes parent =
    let go [] _ = []
        go (n:ns) idx = makeNode n nodes idx parent : go ns (idx + 1)
    in go nodes 0

-- | Create a text node with the given text content
makeTextNode :: Text -> XMLNode
makeTextNode text = XMLText (TE.encodeUtf8 text) 0 Nothing

-- | Create an element node with the given name and attributes
makeAttributedNode :: Text -> [(Text, Text)] -> XMLNode
makeAttributedNode name attrs =
    let attrStr = T.concat [T.pack " " <> k <> T.pack "=\"" <> v <> T.pack "\"" | (k, v) <- attrs]
        xmlStr = T.pack "<" <> name <> attrStr <> T.pack "/>"
        Right doc = X.parse (TE.encodeUtf8 xmlStr)
        node = head $ X.children doc
    in XMLNode node 0 Nothing

-- | Create an element node with the given name, attributes, and child nodes
makeElementNode :: Maybe XMLNode -> Text -> [(Text, Text)] -> [XMLNode] -> XMLNode
makeElementNode parent name attrs children =
    let attrStr = T.concat [T.pack " " <> k <> T.pack "=\"" <> v <> T.pack "\"" | (k, v) <- attrs]
        childrenStr = T.concat [renderNode child | child <- children]
        xmlStr = T.pack "<" <> name <> attrStr <> T.pack ">" <> childrenStr <> T.pack "</" <> name <> T.pack ">"
        Right doc = X.parse (TE.encodeUtf8 xmlStr)
        node = head $ X.children doc
    in XMLNode node 0 parent
  where
    renderNode :: XMLNode -> Text
    renderNode (XMLNode n _ _) = TE.decodeUtf8 $ X.outer n
    renderNode (XMLText txt _ _) = TE.decodeUtf8 txt

-- | Adds attributes to an existing XMLNode.
-- If the node is an XMLText node, it raises an error.
-- For an XMLNode, it reconstructs the node with the new and existing attributes.
addAttributes :: XMLNode -> [(Text, Text)] -> XMLNode
addAttributes (XMLText {}) _ = error "addAttributes: Cannot add attributes to a text node."
addAttributes (XMLNode xnode idx parent) newAttrs =
    let
        nodeName' = decodeUtf8Safe $ X.name xnode

        -- Convert existing X.Attribute to [(Text, Text)]
        existingAttrsList :: [(Text, Text)]
        existingAttrsList = map (\(X.Attribute k v) -> (decodeUtf8Safe k, decodeUtf8Safe v)) (X.attributes xnode)

        -- Merge attributes: new attributes override existing ones if keys conflict
        -- 1. Convert both lists to Maps (newAttrs takes precedence)
        -- 2. Union the maps
        -- 3. Convert back to list for rendering
        mergedAttrsMap = Map.union (Map.fromList newAttrs) (Map.fromList existingAttrsList)
        mergedAttrsList = Map.toList mergedAttrsMap

        attrStr = T.concat [T.pack " " <> k <> T.pack "=\"" <> v <> T.pack "\"" | (k, v) <- mergedAttrsList]

        -- Render children content
        childrenContent :: [Either BS.ByteString X.Node]
        childrenContent = X.contents xnode

        renderChildContent :: Either BS.ByteString X.Node -> Text
        renderChildContent (Left bs) = decodeUtf8Safe bs
        renderChildContent (Right childNode) = decodeUtf8Safe $ X.outer childNode

        childrenStr = T.concat $ map renderChildContent childrenContent

        -- Construct the new XML string
        xmlStr = if T.null childrenStr && not (T.null nodeName') && T.last nodeName' == '/' -- Self-closing tag check (simple)
                 then T.pack "<" <> nodeName' <> attrStr <> T.pack "/>" -- This might be too simple for complex self-closing logic
                 else T.pack "<" <> nodeName' <> attrStr <> T.pack ">" <> childrenStr <> T.pack "</" <> nodeName' <> T.pack ">"

        -- Parse the new XML string to get a new X.Node
        -- hexml's parse function returns a Document, which is a list of Nodes (usually one root)
        Right doc = X.parse (TE.encodeUtf8 xmlStr)
        newNode = case X.children doc of -- X.children of Document gives top-level nodes
                    (n:_) -> n
                    []    -> error $ "addAttributes: Failed to parse reconstructed XML for node: " ++ T.unpack nodeName'
                                    ++ " with XML string: " ++ T.unpack xmlStr
    in XMLNode newNode idx parent

-- | Quasi-quoter for XPath expressions
-- Helper to trim leading and trailing whitespace
trim :: String -> String
trim = dropWhileEnd isSpace . dropWhile isSpace

-- | Quasi-quoter for XPath expressions
x :: QuasiQuoter
x = QuasiQuoter
    { quoteExp = \str ->
        let trimmedStr = trim str -- Trim whitespace before parsing
        in case parseXPath trimmedStr of
             Left err -> error $ "Invalid XPath expression: " ++ show err ++ " (in \"" ++ str ++ "\")" -- Include original string in error
             Right expr -> [| expr |]
    , quotePat = error "XPath expressions cannot be used in patterns"
    , quoteType = error "XPath expressions cannot be used in types"
    , quoteDec = error "XPath expressions cannot be used in declarations"
    }

-- | Prepends the Parent (..) component to an XPath expression.
parentOf :: XPathExpr -> XPathExpr
parentOf (XPathExpr components) = XPathExpr (Parent : components)

joinXPathExpr :: [XPathExpr] -> XPathExpr
joinXPathExpr exprs = XPathExpr (concatMap unXPathExpr exprs)
